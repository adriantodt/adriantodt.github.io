{"version":3,"file":"adriantodt.github.io.js","sources":["kotlin/math.kt","util/Preconditions.kt","comparisons/Comparisons.kt","kotlin/Comparator.kt","generated/_Collections.kt","generated/_Strings.kt","generated/_Maps.kt","../../../../../src/main/kotlin/Color.kt","collections/Maps.kt","../../../../../src/main/kotlin/Dimension.kt","../../../../../src/main/kotlin/FallingPixel.kt","../../../../../src/main/kotlin/PixelatedLogo.kt","util/Standard.kt","collections/Collections.kt","collections/MutableCollections.kt","../../../../../src/main/kotlin/ShootingStar.kt","../../../../../src/main/kotlin/ShootingStarsJS.kt","generated/_Sequences.kt","../../../../../src/main/kotlin/main.kt"],"sourcesContent":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, { it.iterator() })\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.toHashSet()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n",null],"names":[],"mappings":"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"}